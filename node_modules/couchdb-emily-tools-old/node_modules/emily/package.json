{
  "name": "emily",
  "description": "Runtime agnostic JS library for scalable web applications.",
  "version": "3.0.2",
  "homepage": "http://flams.github.com/emily/",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/flams/emily/master/LICENSE"
    }
  ],
  "files": [
    "src",
    "LICENSE"
  ],
  "author": {
    "name": "Olivier Scherrer",
    "email": "pode.fr@gmail.com"
  },
  "devDependencies": {
    "promises-aplus-tests": ">=2.0.3",
    "jasmine-node": "~1.14.3"
  },
  "keywords": [
    "library",
    "AMD/commonJS",
    "Promise",
    "Observable",
    "StateMachine",
    "Store",
    "scalable webapp"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:flams/emily.git"
  },
  "bugs": {
    "url": "https://github.com/flams/emily/issues"
  },
  "main": "src/Emily.js",
  "engines": {
    "node": ">= 0.6.0"
  },
  "dependencies": {
    "get-global": "0.0.1",
    "simple-object-mixin": "0.0.1",
    "compare-numbers": "0.0.1",
    "object-count": "0.0.1",
    "shallow-diff": "0.0.2",
    "nested-property": "0.0.2",
    "to-array": "~0.1.4",
    "shallow-copy": "0.0.1",
    "synchronous-fsm": "0.0.3",
    "watch-notify": "0.0.2",
    "highway": "0.0.2",
    "observable-store": "0.0.3",
    "transport": "0.0.3",
    "simple-loop": "0.0.3",
    "get-closest": "0.0.2"
  },
  "scripts": {
    "test": "jasmine-node specs/",
    "test-promise": "node tools/promise-test/runTest.js"
  },
  "readme": "##What is Emily?\n\n * Emily is a JS library for building scalable web applications.\n * It's runtime agnostic as it doesn't rely on the DOM.\n * It's ready for realtime applications.\n * It's only a set of AMD/commonJS modules, your module loader is the framework\n * It's ready for being used with other frameworks.\n * It only relies on standard features\n * It eases the development of MV* applications by providing the M\n\n##What modules does it provide?\n\n * Observable: the all mighty observer design pattern.\n * Store: the spine of your MV* application.\n * Promise: a fully compliant promise/A+ implementation following [promiseA+-tests](https://github.com/promises-aplus/promises-tests)\n * StateMachine: don't hide your states and transitions behind if/else anymore.\n * Transport: make requests to anything node.js has access to.\n * Tools: these functions you always need and rewrite.\n * Router: set routes with associated actions and navigate to them while keeping tack of the history\n\n##How do I use it?\n\n```\nnpm install emily\n```\n\n```js\n\tvar emily = require(\"emily\");\n\n\tvar StateMachine = emily.StateMachine;\n\tvar Observable = emily.Observable;\n\tvar Promise = emily.Promise;\n\tvar Router = emily.Router;\n\tvar StateMachine = emily.StateMachine;\n\tvar Store = emily.Store;\n\tvar Tools = emily.Tools;\n\tvar Transport = emily.Transport;\n\n\t// ...\n```\n\n##Integration tests:\n\n###Observable\n\n```js\ndescribe(\"Observable implements the Observer design pattern, also called publish subscribe\", function () {\n\n    it(\"has a notify function for publishing something on a topic\", function () {\n        var observable = new Observable(),\n            scope = null,\n            expectedScope = {},\n            message;\n\n        observable.watch(\"topic\", function listener(something) {\n            message = something;\n            scope = this;\n        }, expectedScope);\n\n        observable.notify(\"topic\", \"hello\");\n\n        expect(message).toBe(\"hello\");\n\n        expect(expectedScope).toBe(scope);\n    });\n\n    it(\"can listen to events on a topic only once\", function () {\n        var observable = new Observable(),\n            listener = jasmine.createSpy(),\n            handle = null;\n\n        handle = observable.once(\"topic\", listener, this);\n\n        expect(observable.hasObserver(handle)).toBe(true);\n\n        observable.notify(\"topic\", 1, 2, 3);\n\n        expect(listener).toHaveBeenCalledWith(1, 2, 3);\n\n        listener.reset();\n\n        expect(observable.hasObserver(handle)).toBe(false);\n\n        observable.notify(\"topic\", 1, 2, 3);\n\n        expect(listener).not.toHaveBeenCalled();\n    });\n\n    it(\"notifies several listeners in the order they were added\", function () {\n        var observable = new Observable(),\n            order = [];\n\n        observable.watch(\"topic\", function listener1() {  order.push(1); });\n        observable.watch(\"topic\", function listener2() {  order.push(2); });\n        observable.watch(\"topic\", function listener3() {  order.push(3); });\n\n        observable.notify(\"topic\");\n\n        expect(order[0]).toBe(1);\n        expect(order[1]).toBe(2);\n        expect(order[2]).toBe(3);\n    });\n\n    it(\"should continue publishing on all the listeners even if one of them fails\", function () {\n        var observable = new Observable(),\n            order = [];\n\n        observable.watch(\"topic\", function listener1() {  order.push(1); });\n        observable.watch(\"topic\", function listener2() {  throw new Error(\"this listener fails\"); });\n        observable.watch(\"topic\", function listener3() {  order.push(3); });\n\n        observable.notify(\"topic\");\n\n        expect(order[0]).toBe(1);\n        expect(order[1]).toBe(3);\n    });\n\n    it(\"can bind the this object of a listener to a given object and pass multiple things on the topic\", function () {\n        var observable = new Observable(),\n            message1,\n            message2,\n            message3,\n            context;\n\n        observable.watch(\"topic\", function listener(something1, something2, something3) {\n            message1 = something1;\n            message2 = something2;\n            message3 = something3;\n            context = this;\n        }, this);\n\n        observable.notify(\"topic\", \"hello\", \"this is\", \"emily\");\n\n        expect(message1).toBe(\"hello\");\n        expect(message2).toBe(\"this is\");\n        expect(message3).toBe(\"emily\");\n        expect(context).toBe(this);\n    });\n\n    it(\"can remove a listener from a topic\", function () {\n        var observable = new Observable(),\n            removed = true;\n\n        var handle = observable.watch(\"topic\", function listener(something) {\n            removed = false;\n        });\n\n        // Remove the listener so it doesn't get called anymore\n        observable.unwatch(handle);\n\n        observable.notify(\"topic\");\n\n        expect(removed).toBe(true);\n    });\n\n    it(\"can remove all listeners from a given topic\", function () {\n        var observable = new Observable(),\n            topics = [];\n\n        observable.watch(\"topic1\", function listener1() { topics.push(\"topic1\"); });\n        observable.watch(\"topic1\", function listener2() { topics.push(\"topic1\"); });\n        observable.watch(\"topic2\", function listener3() { topics.push(\"topic2\"); });\n\n        observable.unwatchAll(\"topic1\");\n\n        observable.notify(\"topic1\");\n        observable.notify(\"topic2\");\n\n        expect(topics.length).toBe(1);\n        expect(topics[0]).toBe(\"topic2\");\n    });\n\n    it(\"can remove all listeners\", function () {\n        var observable = new Observable(),\n            topics = [];\n\n        observable.watch(\"topic1\", function listener1() { topics.push(\"topic1\"); });\n        observable.watch(\"topic1\", function listener2() { topics.push(\"topic1\"); });\n        observable.watch(\"topic2\", function listener3() { topics.push(\"topic2\"); });\n\n        observable.unwatchAll();\n\n        observable.notify(\"topic1\");\n        observable.notify(\"topic2\");\n\n        expect(topics.length).toBe(0);\n    });\n\n});\n```\n###Tools\n\n```js\ndescribe(\"Tools is a set of tools commonly used in JavaScript applications\", function () {\n\n    describe(\"Tools.getGlobal can retrieve the global object\", function () {\n\n        it(\"returns the global object\", function () {\n            expect(Tools.getGlobal()).toBe(__Global);\n        });\n    });\n\n    describe(\"Tools.mixin can add an object's properties to another object\", function () {\n\n        it(\"takes the properties of the second object to mix them into the first one\", function () {\n            var source = {c: 30, d: 40},\n                destination = {a: 10, b: 20};\n\n            Tools.mixin(source, destination);\n\n            expect(destination.a).toBe(10);\n            expect(destination.b).toBe(20);\n            expect(destination.c).toBe(30);\n            expect(destination.d).toBe(40);\n        });\n\n        it(\"overrides the destination's values with the source ones by default\", function () {\n            var source = {c: 30, d: 40},\n                destination = {a: 10, b: 20, c: 25};\n\n            Tools.mixin(source, destination);\n\n            // The destination's c has been replaced by the source's one\n            expect(destination.c).toBe(30);\n        });\n\n        it(\"can prevent the desitnation's values to be replaced\", function () {\n            var source = {c: 30, d: 40},\n                destination = {a: 10, b: 20, c: 25};\n\n            Tools.mixin(source, destination, true);\n\n            // The destination's c has been replaced by the source's one\n            expect(destination.c).toBe(25);\n        });\n\n        it(\"also returns the destination object\", function () {\n            var source = {c: 30, d: 40},\n                destination = {a: 10, b: 20, c: 25};\n\n            expect(Tools.mixin(source, destination, true)).toBe(destination);\n        });\n    });\n\n    describe(\"Tools.count tells how many own properties an Object has\", function () {\n\n        it(\"only counts own properties\", function () {\n            var object = {a: 10, b: 20};\n\n            expect(Tools.count(object)).toBe(2);\n        });\n\n    });\n\n    describe(\"Tools.compareNumbers is useful for telling if a number if greater, equal or lower than another one\", function () {\n\n        it(\"tells if a number is greater than another one\", function () {\n            expect(Tools.compareNumbers(2.3, 2.2)).toBe(1);\n        });\n\n        it(\"tells if a number equals another one\", function () {\n            expect(Tools.compareNumbers(2.2, 2.2)).toBe(0);\n        });\n\n        it(\"tells if a number is lower than another one\", function () {\n            expect(Tools.compareNumbers(2.1, 2.2)).toBe(-1);\n        });\n\n        it(\"can ASC sort numbers when using Array.sort\", function () {\n            var array = [0, 2, 9, 4, 1, 7, 3, 12, 11, 5, 6, 8, 10];\n\n            array.sort(Tools.compareNumbers);\n\n            expect(array[10]).toBe(10);\n            expect(array[11]).toBe(11);\n        });\n\n    });\n\n    describe(\"Tools.toArray transforms an array like object, like arguments or a nodeList to an actual array\", function () {\n\n        it(\"transforms a list of arguments to an array\", function () {\n            (function () {\n                var args = Tools.toArray(arguments);\n\n                expect(Array.isArray(args)).toBe(true);\n\n            })();\n        });\n\n        it(\"transforms a nodelist into an array\", function () {\n            if (__Global.document) {\n                var all = Tools.toArray(document.querySelectorAll(\"*\"));\n\n                expect(Array.isArray(all)).toBe(true);\n            }\n        });\n    });\n\n    describe(\"Tools.loop abstracts the difference between iterating over an object and an array\", function () {\n\n        it(\"can iterate over an array\", function () {\n            var array = [0, 1, 2, 3];\n\n            var _self = this;\n\n            Tools.loop(array, function (value, index, iterated) {\n                expect(iterated).toBe(array);\n                expect(array[index]).toBe(value);\n                // The context in which to run this function can also be given\n                expect(this).toBe(_self);\n            }, this);\n        });\n\n        it(\"can iterate over an array which length varies\", function () {\n            var iterated = [1],\n                nbOfCalls = 0;\n\n            Tools.loop(iterated, function (value) {\n                if (nbOfCalls < 10) {\n                    iterated.push(1);\n                    nbOfCalls++;\n                }\n            });\n\n            expect(iterated.length).toBe(11);\n        });\n\n        it(\"can iterate over an object\", function () {\n            var object = {a: 10, b: 20};\n\n            Tools.loop(object, function (value, key, obj) {\n                expect(object).toBe(obj);\n                expect(object[key]).toBe(value);\n            });\n        });\n    });\n\n    describe(\"Tools.objectsDiffs returns an object describing the differences between two objects\", function () {\n\n        it(\"tells what was added in an array\", function () {\n            var array1 = [\"a\", \"b\", \"c\"],\n                array2 = [\"a\", \"b\", \"c\", \"d\", \"e\"];\n\n            var diff = Tools.objectsDiffs(array1, array2);\n            // The third item of array2 was added\n            expect(diff.added[0]).toBe(3);\n            // The fourth item too\n            expect(diff.added[1]).toBe(4);\n        });\n\n        it(\"tells what was removed\", function () {\n            var array1 = [\"a\", \"b\", \"c\"],\n                array2 = [\"a\", \"b\"];\n\n            var diff = Tools.objectsDiffs(array1, array2);\n            // The third item of array2 was deleted\n            expect(diff.deleted[0]).toBe(2);\n        });\n\n        it(\"tells what was updated\", function () {\n            var array1 = [\"a\", \"b\", \"c\"],\n                array2 = [\"a\", \"d\", \"e\"];\n\n            var diff = Tools.objectsDiffs(array1, array2);\n            // The second item of array2 was updated\n            expect(diff.updated[0]).toBe(1);\n            // The third one too\n            expect(diff.updated[1]).toBe(2);\n        });\n\n        it(\"tells what remains unchanged\", function () {\n            var array1 = [\"a\", \"b\", \"c\"],\n                array2 = [\"a\", \"d\", \"e\"];\n\n            var diff = Tools.objectsDiffs(array1, array2);\n            // The first item remains unchanged\n            expect(diff.unchanged[0]).toBe(0);\n        });\n\n        it(\"also works with objects\", function () {\n            var object1 = { a: 10, b: 20, c: 30},\n                object2 = { b: 30, c: 30, d: 40};\n\n            var diff = Tools.objectsDiffs(object1, object2);\n\n            expect(diff.deleted[0]).toBe(\"a\");\n            expect(diff.updated[0]).toBe(\"b\");\n            expect(diff.unchanged[0]).toBe(\"c\");\n            expect(diff.added[0]).toBe(\"d\");\n        });\n\n    });\n\n    describe(\"Tools.setNestedProperty sets the property of an object nested in one or more objects\", function () {\n\n        it(\"sets the property of an object deeply nested and creates the missing ones\", function () {\n            var object = {};\n\n            Tools.setNestedProperty(object, \"a.b.c.d.e.f\", \"emily\");\n\n            expect(object.a.b.c.d.e.f).toBe(\"emily\");\n        });\n\n        it(\"returns the value if the first parameter is not an object\", function () {\n            expect(Tools.setNestedProperty(\"emily\")).toBe(\"emily\");\n        });\n\n        it(\"also works if there are arrays in the path, but it doesn't create an array\", function () {\n            var object = {};\n\n            Tools.setNestedProperty(object, \"a.b.c.0.d\", \"emily\");\n\n            expect(object.a.b.c[0].d).toBe(\"emily\");\n            expect(Array.isArray(object.a.b.c)).toBe(false);\n        });\n\n    });\n\n    describe(\"Tools.getNestedProperty gets the property of an object nested in other objects\", function () {\n\n        it(\"gets the property of an object deeply nested in another one\", function () {\n            var object = {b:{c:{d:{e:1}}}};\n\n            expect(Tools.getNestedProperty(object, \"b.c\")).toBe(object.b.c);\n            expect(Tools.getNestedProperty(object, \"b.c.d.e\")).toBe(1);\n        });\n\n        it(\"also works if an array is in the path\", function () {\n            var object = {a: [{b: 1}]};\n\n            expect(Tools.getNestedProperty(object, \"a.0.b\")).toBe(1);\n        });\n\n    });\n\n    describe(\"Tools.closest finds the closest number to a base number in an array and returns its index\", function () {\n\n        it(\"gets the closest number\", function () {\n            expect(Tools.closest(10, [30, 5, 40, 20])).toBe(1);\n            expect(Tools.closest(25, [30, 5, 40, 20])).toBe(0);\n            expect(Tools.closest(30, [30, 5, 40, 20])).toBe(0);\n            expect(Tools.closest(45, [30, 5, 40, 20])).toBe(2);\n        });\n\n        it(\"gets the closest number that is greater\", function () {\n            expect(Tools.closestGreater(10, [30, 5, 40, 20])).toBe(3);\n            expect(Tools.closestGreater(25, [30, 5, 40, 20])).toBe(0);\n            expect(Tools.closestGreater(30, [30, 5, 40, 20])).toBe(0);\n            expect(Tools.closestGreater(45, [30, 5, 40, 20])).toBeUndefined();\n        });\n\n        it(\"gets the closest number that is lower\", function () {\n            expect(Tools.closestLower(10, [30, 5, 40, 20])).toBe(1);\n            expect(Tools.closestLower(25, [30, 5, 40, 20])).toBe(3);\n            expect(Tools.closestLower(30, [30, 5, 40, 20])).toBe(0);\n            expect(Tools.closestLower(45, [30, 5, 40, 20])).toBe(2);\n        });\n\n    });\n\n});\n```\n###Store\n\n```js\ndescribe(\"Store is an observable data structure that publishes events whenever it's updated\", function () {\n\n    it(\"can store its data in an object\", function () {\n        var store = new Store({});\n\n        store.set(\"key\", \"emily\");\n        store.set(\"otherKey\", 2);\n\n        expect(store.get(\"key\")).toBe(\"emily\");\n        expect(store.get(\"otherKey\")).toBe(2);\n\n        expect(store.has(\"key\")).toBe(true);\n\n        expect(store.del(\"key\")).toBe(true);\n        expect(store.del(\"key\")).toBe(false);\n        expect(store.has(\"key\")).toBe(false);\n    });\n\n    it(\"can store data in an array\", function () {\n        var store = new Store([]);\n\n        store.set(0, \"emily\");\n        store.set(1, 1);\n\n        expect(store.get(0)).toBe(\"emily\");\n        expect(store.get(1)).toBe(1);\n\n        expect(store.del(0)).toBe(true);\n        expect(store.get(0)).toBe(1);\n    });\n\n    it(\"can be initialized with data\", function () {\n        var store = new Store({a: 10});\n\n        expect(store.get(\"a\")).toBe(10);\n    });\n\n    it(\"can be initialized two times with the same data but the data are not shared between them\", function () {\n        var data = {a: 10},\n            store1 = new Store(data),\n            store2 = new Store(data);\n\n        store1.set(\"b\", 20);\n\n        expect(store2.has(\"b\")).toBe(false);\n    });\n\n    it(\"publishes events when a store is updated\", function () {\n        var store = new Store([]),\n            itemAdded = false,\n            itemUpdated = false,\n            itemDeleted = false,\n            handle;\n\n        // Listening to the events uses the same API as the Observable\n        handle = store.watch(\"added\", function (key) {\n            itemAdded = key;\n        }, this);\n\n        store.watch(\"updated\", function (key) {\n            itemUpdated = key;\n        }, this);\n\n        store.watch(\"deleted\", function (key) {\n            itemDeleted = key;\n        }, this);\n\n        store.set(0, \"emily\");\n\n        expect(itemAdded).toBe(0);\n\n        store.set(0, \"olives\");\n\n        expect(itemUpdated).toBe(0);\n\n        store.del(0);\n\n        expect(itemDeleted).toBe(0);\n\n        store.unwatch(handle);\n    });\n\n    it(\"publishes events when a value in the store is updated\", function () {\n        var store = new Store([]),\n            spyNewValue,\n            spyOldValue,\n            spyEvent,\n            handle;\n\n        handle = store.watchValue(0, function (newValue, action, oldValue) {\n            spyNewValue = newValue;\n            spyOldValue = oldValue;\n            spyEvent = action;\n        }, this);\n\n        store.set(0, \"emily\");\n\n        expect(spyNewValue).toBe(\"emily\");\n        expect(spyEvent).toBe(\"added\");\n\n        store.set(0, \"olives\");\n\n        expect(spyNewValue).toBe(\"olives\");\n        expect(spyEvent).toBe(\"updated\");\n        expect(spyOldValue).toBe(\"emily\");\n\n        store.unwatchValue(handle);\n    });\n\n    it(\"works the same with objects\", function () {\n        var store = new Store({}),\n            spyNewValue,\n            spyOldValue,\n            spyEvent;\n\n        store.watchValue(\"key\", function (newValue, action, oldValue) {\n            spyNewValue = newValue;\n            spyOldValue = oldValue;\n            spyEvent = action;\n        }, this);\n\n        store.set(\"key\", \"emily\");\n\n        expect(spyNewValue).toBe(\"emily\");\n        expect(spyEvent).toBe(\"added\");\n\n        store.set(\"key\", \"olives\");\n\n        expect(spyNewValue).toBe(\"olives\");\n        expect(spyEvent).toBe(\"updated\");\n        expect(spyOldValue).toBe(\"emily\");\n    });\n\n    it(\"can update the property of an object nested in a store and publish an event\", function () {\n        var store = new Store({\n                key: {}\n            }),\n            updatedValue = false;\n\n        store.watchValue(\"key\", function (value) {\n            updatedValue = value;\n        }, this);\n\n        store.update(\"key\", \"a.b.c\", \"emily\");\n\n        expect(updatedValue.a.b.c).toBe(\"emily\");\n\n    });\n\n    it(\"can delete multiple items in one function call\", function () {\n        var store = new Store([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]);\n\n        store.delAll([0,1,2]);\n\n        expect(store.count()).toBe(3);\n\n        expect(store.get(0)).toBe(\"d\");\n        expect(store.get(1)).toBe(\"e\");\n        expect(store.get(2)).toBe(\"f\");\n    });\n\n    it(\"can delete multiple properties in one function call\", function () {\n        var store = new Store({a: 10, b: 20, c: 30});\n\n        store.delAll([\"a\", \"b\"]);\n\n        expect(store.count()).toBe(1);\n\n        expect(store.has(\"a\")).toBe(false);\n        expect(store.has(\"b\")).toBe(false);\n        expect(store.has(\"c\")).toBe(true);\n    });\n\n    it(\"can compute properties from other properties\", function () {\n        var store = new Store({a: 1000, b: 336}),\n            observedComputed;\n\n        store.compute(\"c\", [\"a\", \"b\"], function () {\n            return this.get(\"a\") + this.get(\"b\");\n        }, store);\n\n        expect(store.get(\"c\")).toBe(1336);\n\n        store.watchValue(\"c\", function (value) {\n            observedComputed = value;\n        });\n\n        store.set(\"b\", 337);\n\n        expect(store.get(\"c\")).toBe(1337);\n        expect(observedComputed).toBe(1337);\n    });\n\n    it(\"can alter the inner data structure and publish changes when it's an array\", function () {\n        var store = new Store([0, 2, 3]),\n            newValue;\n\n        store.watchValue(1, function (value) {\n            newValue = value;\n        });\n        // Splice can alter the store\n        store.alter(\"splice\", 1, 0, 1); // [0,1,2,3]\n\n        expect(store.get(1)).toBe(1);\n        expect(newValue).toBe(1);\n\n        // Map doesn't alter it, just like calling map on any array\n        var newArray = store.alter(\"map\", function (value) {\n            return value * 2;\n        });\n\n        expect(newArray[3]).toBe(6);\n    });\n\n    it(\"can also alter the inner structure and publish changes when it's an object\", function () {\n        var store = new Store({a: 10});\n\n        expect(store.alter(\"hasOwnProperty\", \"a\")).toBe(true);\n    });\n\n    it(\"can also directly call the methods of the inner structure without further publishing events\", function () {\n        var store = new Store([0, 1, 2]);\n\n        expect(store.proxy(\"slice\", 1, 2)).toEqual([1]);\n    });\n\n    it(\"has a function for iterating over it the same way being based on an object or an array\", function () {\n        var store = new Store({a: 10, b: 20}),\n            calls = [];\n\n        store.loop(function () {\n            calls.push(arguments);\n        });\n\n        // Note that it's lucky that this test passes\n        // as loop doesn't guarantee the order in case of an object!\n        expect(calls[0][0]).toBe(10);\n        expect(calls[0][1]).toBe(\"a\");\n\n        expect(calls[1][0]).toBe(20);\n        expect(calls[1][1]).toBe(\"b\");\n\n        store = new Store([\"a\", \"b\"]);\n        calls = [];\n\n        store.loop(function () {\n            calls.push(arguments);\n        });\n\n        expect(calls[0][0]).toBe(\"a\");\n        expect(calls[0][1]).toBe(0);\n\n        expect(calls[1][0]).toBe(\"b\");\n        expect(calls[1][1]).toBe(1);\n    });\n\n    it(\"has a function for resetting the whole store\", function () {\n        var store = new Store({a: 10}),\n            itemAdded;\n\n        // Calling reset fires the diff events\n        store.watch(\"added\", function (key) {\n            itemAdded = key;\n        });\n\n        store.reset([\"a\"]);\n\n        expect(store.get(0)).toBe(\"a\");\n\n        expect(itemAdded).toBe(0);\n    });\n\n    it(\"can return the jsonified version of itself\", function () {\n        var store = new Store({a: undefined}),\n            jsonified;\n\n        expect(store.has(\"a\")).toBe(true);\n\n        jsonified = store.toJSON();\n\n        expect(jsonified).toBe(\"{}\");\n    });\n\n    it(\"can return it's internal structure\", function () {\n        var store = new Store({a: 10}),\n            internal;\n\n        internal = store.dump();\n\n        expect(internal.a).toBe(10);\n\n        // The internal is not the object passed at init\n        expect(store).not.toBe(internal);\n\n    });\n\n});\n```\n###StateMachine\n\n```js\ndescribe(\"StateMachine helps you with the control flow of your apps by removing branching if/else\", function () {\n\n    it(\"will call specific actions depending on the current state and the triggered event\", function () {\n        var passCalled,\n            coinCalled,\n\n            stateMachine = new StateMachine(\"opened\", {\n            // It has an 'opened' state\n            \"opened\": [\n                // That accepts a 'pass' event that will execute the 'pass' action\n                [\"pass\", function pass(event) {\n                    passCalled = event;\n                // And when done, it will transit to the 'closed' state\n                }, \"closed\"]\n            ],\n\n            // It also has a 'closed' state\n            \"closed\": [\n                // That accepts a 'coin' event that will execute the 'coin' action\n                [\"coin\", function coin(event) {\n                    coinCalled = event;\n                // And when done, it will transit back to the 'opened' state\n                }, \"opened\"]\n            ]\n        });\n\n        expect(stateMachine.getCurrent()).toBe(\"opened\");\n\n        expect(stateMachine.event(\"nonExistingState\")).toBe(false);\n        expect(stateMachine.event(\"pass\", \"hello\")).toBe(true);\n        expect(passCalled).toBe(\"hello\");\n\n        expect(stateMachine.getCurrent()).toBe(\"closed\");\n        expect(stateMachine.event(\"coin\", \"2p\")).toBe(true);\n        expect(coinCalled).toBe(\"2p\");\n\n        expect(stateMachine.getCurrent()).toBe(\"opened\");\n    });\n\n    it(\"executes the action in the given scope\", function () {\n        var passThisObject,\n            coinThisObject,\n            scope = {},\n\n        stateMachine = new StateMachine(\"opened\", {\n            \"opened\": [\n                [\"pass\", function pass() {\n                    passThisObject = this;\n                }, scope, \"closed\"]\n            ],\n            \"closed\": [\n                [\"coin\", function coin() {\n                    coinThisObject = this;\n                }, scope, \"opened\"]\n            ]\n        });\n\n        stateMachine.event(\"pass\");\n        expect(passThisObject).toBe(scope);\n\n        stateMachine.event(\"coin\");\n        expect(coinThisObject).toBe(scope);\n    });\n\n    it(\"can handle events that don't necessarily change the state\", function () {\n        var coinCalled,\n            stateMachine = new StateMachine(\"opened\", {\n            \"opened\": [\n                [\"pass\", function pass() {\n                    passThisObject = this;\n                }, \"closed\"],\n                [\"coin\", function coin() {\n                    coinCalled = true;\n                }]\n            ],\n            \"closed\": [\n                [\"coin\", function coin() {\n                    coinThisbject = this;\n                }, \"opened\"]\n            ]\n        });\n\n        stateMachine.event(\"coin\");\n        expect(coinCalled).toBe(true);\n        expect(stateMachine.getCurrent()).toBe(\"opened\");\n\n    });\n\n    it(\"can execute given actions upon entering or leaving a state\", function () {\n        var onEnter,\n            onExit,\n            stateMachine = new StateMachine(\"opened\", {\n            \"opened\": [\n                [\"pass\", function pass() {\n                    //\n                }, \"closed\"],\n\n                // Exit will be called upon leaving opened\n                [\"exit\", function exit() {\n                    onExit = true;\n                }]\n            ],\n            \"closed\": [\n\n                // Whereas entry will be called upon entering the state\n                [\"entry\", function entry() {\n                    onEnter = true;\n                }],\n                [\"coin\", function coin() {\n                    //\n                }, \"opened\"]\n            ]\n        });\n\n        stateMachine.event(\"pass\");\n\n        expect(onExit).toBe(true);\n        expect(onExit).toBe(true);\n\n        expect(stateMachine.getCurrent()).toBe(\"closed\");\n    });\n\n    it(\"can be advanced to a given state\", function () {\n        var stateMachine = new StateMachine(\"opened\", {\n            \"opened\": [\n                [\"pass\", function pass() {\n                    passThisObject = this;\n                }, \"closed\"]\n            ],\n            \"closed\": [\n                [\"coin\", function coin() {\n                    coinThisObject = this;\n                }, \"opened\"]\n            ]\n        });\n\n        expect(stateMachine.advance(\"\")).toBe(false);\n        expect(stateMachine.advance(\"closed\")).toBe(true);\n        expect(stateMachine.getCurrent()).toBe(\"closed\");\n\n        expect(stateMachine.advance(\"opened\")).toBe(true);\n        expect(stateMachine.getCurrent()).toBe(\"opened\");\n    });\n\n});\n```\n###Transport\n\n```js\ndescribe(\"Transport hides and centralizes the logic behind requests\", function () {\n\n    it(\"issues requests to request handlers\", function () {\n\n        var onEndCalled = false;\n\n        var requestsHandlers = new Store({\n            // This function will handle the request specified by payload.\n            // It will call the onEnd request when it has received all the data\n            // It will call onData for each chunk of data that needs to be sent\n            myRequestHandler: function (payload, onEnd) {\n                if (payload == \"whoami\") {\n                    onEnd(\"emily\");\n                }\n            }\n        });\n\n        var transport = new Transport(requestsHandlers);\n\n        // Issue a request on myRequestHandler with \"whoami\" in the payload\n        transport.request(\"myRequestHandler\", \"whoami\", function onEnd() {\n            onEndCalled = true;\n        });\n\n        expect(onEndCalled).toBe(true);\n    });\n\n    it(\"accepts objects as payloads\", function () {\n\n        var requestsHandlers = new Store({\n            myRequestHandler: function (payload, onEnd) {\n                onEnd(\"Hi \" + payload.firstname + \" \" + payload.lastname);\n            }\n        }),\n        transport,\n        response;\n\n        transport = new Transport(requestsHandlers);\n\n        transport.request(\"myRequestHandler\", {\n            firstname: \"olivier\",\n            lastname: \"scherrer\"\n        }, function onEnd(data) {\n            response = data;\n        });\n\n        expect(response).toBe(\"Hi olivier scherrer\");\n\n    });\n\n    it(\"can also listen to channels and receive data in several chunks\", function () {\n\n        var requestsHandlers = new Store({\n            // When onEnd is called, no further data can be sent.\n            // But when the channel must no be closed, onData can be called instead\n            myRequestHandler: function (payload, onEnd, onData) {\n                onData(\"chunk1\");\n                onData(\"chunk2\");\n                onData(\"chunk3\");\n                onEnd(\"chunk4\");\n            }\n        }),\n        response = [];\n\n        var transport = new Transport(requestsHandlers);\n\n        transport.listen(\"myRequestHandler\", {}, function onData(data) {\n            response.push(data);\n        });\n\n        expect(response.length).toBe(4);\n        expect(response[0]).toBe(\"chunk1\");\n        expect(response[3]).toBe(\"chunk4\");\n\n    });\n\n    it(\"can close a listening channel on the client end point\", function () {\n        var aborted = false;\n\n        var requestsHandlers = new Store({\n            myRequestHandler: function () {\n                return function() {\n                    aborted = true;\n                };\n            }\n        }),\n        transport = new Transport(requestsHandlers),\n        abort;\n\n        abort = transport.listen(\"myRequestHandler\", \"\", function () {});\n\n        abort();\n\n        expect(aborted).toBe(true);\n    });\n\n});\n```\n###Router\n\n```js\ndescribe(\"Router determines the navigation in your application\", function () {\n\n    it(\"can navigate to routes and pass arguments\", function () {\n        var router = new Router();\n\n        var routeObserver1 = jasmine.createSpy(),\n            routeObserver2 = jasmine.createSpy(),\n            scope = {},\n            params = {};\n\n        router.set(\"route1\", routeObserver1);\n        router.set(\"route2\", routeObserver2, scope);\n\n        router.navigate(\"route1\", params);\n\n        expect(routeObserver1.wasCalled).toBe(true);\n        expect(routeObserver1.mostRecentCall.args[0]).toBe(params);\n        expect(routeObserver2.wasCalled).toBe(false);\n\n        router.navigate(\"route2\", params);\n\n        expect(routeObserver2.wasCalled).toBe(true);\n        expect(routeObserver2.mostRecentCall.args[0]).toBe(params);\n        expect(routeObserver2.mostRecentCall.object).toBe(scope);\n    });\n\n    it(\"publishes events when navigating to a new route\", function () {\n        var router = new Router();\n\n        var observer = jasmine.createSpy(),\n            scope = {},\n            params = {};\n\n        router.watch(observer, scope);\n\n        router.set(\"route\", function () {});\n\n        router.navigate(\"route\", params);\n\n        expect(observer.wasCalled).toBe(true);\n        expect(observer.mostRecentCall.args[0]).toBe(\"route\");\n        expect(observer.mostRecentCall.args[1]).toBe(params);\n    });\n\n    it(\"keeps track of the history while navigating\", function () {\n        var router = new Router();\n\n        var observer = jasmine.createSpy();\n\n        router.watch(observer);\n\n        router.set(\"route1\", function () {});\n        router.set(\"route2\", function () {});\n        router.set(\"route3\", function () {});\n        router.set(\"route4\", function () {});\n        router.set(\"route5\", function () {});\n\n        router.setMaxHistory(3);\n\n        router.navigate(\"route1\");\n        router.navigate(\"route2\");\n\n        router.back();\n\n        expect(observer.mostRecentCall.args[0]).toBe(\"route1\");\n\n        router.forward();\n\n        expect(observer.mostRecentCall.args[0]).toBe(\"route2\");\n\n        router.navigate(\"route3\");\n\n        router.navigate(\"route4\");\n\n        expect(router.go(-2)).toBe(true);\n\n        expect(observer.mostRecentCall.args[0]).toBe(\"route2\");\n\n        expect(router.back()).toBe(false);\n\n        expect(router.forward()).toBe(true);\n\n        expect(observer.mostRecentCall.args[0]).toBe(\"route3\");\n\n        router.navigate(\"route5\");\n\n        expect(router.forward()).toBe(false);\n\n        router.back();\n\n        expect(observer.mostRecentCall.args[0]).toBe(\"route3\");\n    });\n\n    it(\"can clear the history\", function () {\n        var router = new Router();\n\n        router.set(\"route1\");\n        router.set(\"route2\");\n\n        router.navigate(\"route1\");\n        router.navigate(\"route2\");\n        router.clearHistory();\n\n        expect(router.back()).toBe(false);\n    });\n\n    it(\"can tell the depth of the history\", function () {\n        var router = new Router();\n\n        router.set(\"route1\", function () {});\n        router.navigate(\"route1\");\n        router.navigate(\"route1\");\n        router.navigate(\"route1\");\n        router.navigate(\"route1\");\n        router.navigate(\"route1\");\n\n        expect(router.getHistoryCount()).toBe(5);\n    });\n\n    it(\"has a default max history of 10\", function () {\n        var router = new Router();\n\n        expect(router.getMaxHistory()).toBe(10);\n    });\n\n    it(\"can remove a route\", function () {\n        var router = new Router(),\n            handle;\n\n        handle = router.set(\"route1\");\n\n        router.unset(handle);\n\n        expect(router.navigate(\"route1\")).toBe(false);\n    });\n});\n```\n\n###Promise\n\n```js\ndescribe(\"Promise is a partially Promise/A+ compliant implementation\", function () {\n\n    var Promise = require(\"emily\").Promise;\n\n    it(\"calls the fulfillment callback within scope\", function () {\n        var promise = new Promise(),\n            scope = {},\n            thisObj,\n            value;\n\n        promise.then(function (val) {\n            thisObj = this;\n            value = val;\n        }, scope);\n\n        promise.fulfill(\"emily\");\n\n        expect(value).toBe(\"emily\");\n        expect(thisObj).toBe(scope);\n    });\n\n    it(\"calls the rejection callback within a scope\", function () {\n        var promise = new Promise(),\n            scope = {},\n            thisObj,\n            reason;\n\n        promise.then(null, function (res) {\n            thisObj = this;\n            reason = res;\n        }, scope);\n\n        promise.reject(false);\n\n        expect(reason).toBe(false);\n        expect(thisObj).toBe(scope);\n    });\n\n    it(\"can synchronise a promise with another one, or any thenable\", function () {\n        var promise1 = new Promise(),\n            promise2 = new Promise(),\n            synched;\n\n        promise2.sync(promise1);\n\n        promise2.then(function (value) {\n            synched = value;\n        });\n\n        promise1.fulfill(true);\n\n        expect(synched).toBe(true);\n    });\n\n    it(\"can return the reason of a rejected promise\", function () {\n        var promise = new Promise();\n\n        promise.reject(\"reason\");\n\n        expect(promise.getReason()).toBe(\"reason\");\n    });\n\n    it(\"can return the value of a fulfilled promise\", function () {\n        var promise = new Promise();\n\n        promise.fulfill(\"emily\");\n\n        expect(promise.getValue()).toBe(\"emily\");\n    });\n\n    it(\"passes all the promise-A+ tests specs\", function () {\n        expect('225 tests complete (6 seconds)').toBeTruthy();\n    });\n});\n```\n\n## Changelog\n\n###3.0.2 - 28 APR 2014\n\n* Doc update\n\n####3.0.1 - 27 APR 2014\n\n* Remove unused docs, previous releases and browser builds. Use browserify to use Emily.js in the browser.\n\n####3.0.0 - 27 APR 2014\n\n* Already version 3.0.0! It doesn't change much, but every module has been extracted into it's own module, and Emily just\n packs them together into a great library, because they work nicely together.\n* It does have breaking changes though, the following, unused tools have been removed:\n - Tools.jsonify which was removing unjsonifiable properties like functions and undefined properties\n - Tools.compareObjects which was comparing the keys of two objects to tell if they were the same\n\n####2.0.0 - 05 MAR 2014\n\n* No changes since beta\n\n####2.0.0 beta - 04 FEB 2014\n\n* Completely removed the dependency on requirejs\n* Promise.sync has been renamed to Promise.cast\n\n####1.8.1 - 03 DEC 2013\n\n* Add convenience method observable.once\n\n####1.8.0 - 03 SEP 2013\n\n* Store.reset publishes a \"resetted\" event when the store is resetted\n* Store.reset publishes an \"altered\" event with the store is altered\n\n####1.7.0 - 04 AUG 2013\n\n* Adds router\n\n####1.6.0 - 17 JUNE 2013\n\n* Adds computed properties to the Store\n\n####1.5.0 - 9 JUNE 2013\n\n* Tools now has closest, closestGreater and closestLower for finding the number in an array that is the closest to a base number.\n\n####1.4.0 - 13 MAY 2013\n\n* Store.proxy now gives direct access to the data structure's methods without publishing diffs, which is much faster (useful for slice for instance)\n\n####1.3.5 - 09 MAR 2013\n\n* Added count alias for getNbItems in Store\n* Added proxy alias for alter in Store\n* Updated documentation, added integration tests\n\n####1.3.4 - 03 MAR 2013\n\n* Added advance to the state machine\n\n####1.3.3 - 28 JAN 2013\n\n* Added Store.dump\n* When store publishes a change event, it publishes both the new and the previous value\n\n####1.3.2 - 22 JAN 2013\n\n* Fixed emily-server breaking olives\n* Updated requirejs\n\n####1.3.1 - 1 JAN 2013\n\n* Promise has been updated to pass the promise/A+ specs according to [promiseA+-tests](https://github.com/promises-aplus/promises-tests)\n* Updated StateMachine so new transitions can be added on the fly\n* Moved the CouchDB handler to CouchDB Emily Tools\n\n####1.3.0 - 16 DEC 2012\n\n * Promise has been updated to pass the promise/A specs according to [promise-tests](https://github.com/domenic/promise-tests)\n * The build now includes the source files as you should be able to drop them into your application\n   to decide how you want to load and optimize them\n\n####1.2.0 - 07 OCT 2012\n\nRemoval of CouchDBStore - now part of CouchDB-Emily-Tools\n\n## Going further\n\nCheck out [Olives](https://github.com/flams/olives) for scalable MV* applications in the browser.\n",
  "readmeFilename": "README.md",
  "_id": "emily@3.0.2",
  "dist": {
    "shasum": "56505c43acd33bedec8341f541b4bfbdb7a9dac2"
  },
  "_from": "emily@>=2.0.0",
  "_resolved": "https://registry.npmjs.org/emily/-/emily-3.0.2.tgz"
}
