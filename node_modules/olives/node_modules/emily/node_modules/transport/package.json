{
  "name": "transport",
  "description": "a hub for centralizing all your request handlers within your application",
  "version": "0.0.3",
  "homepage": "https://github.com/cosmosio/transport",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/cosmosio/transport/master/LICENSE"
    }
  ],
  "files": [
    "LICENSE",
    "index.js"
  ],
  "author": {
    "name": "Olivier Scherrer",
    "email": "pode.fr@gmail.com"
  },
  "keywords": [
    "transport",
    "request",
    "handlers",
    "listen",
    "disposable"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:cosmosio/transport.git"
  },
  "bugs": {
    "url": "https://github.com/cosmosio/transport/issues"
  },
  "scripts": {
    "test": "jasmine-node test/"
  },
  "main": "index.js",
  "devDependencies": {
    "jasmine-node": "~1.14.3",
    "observable-store": "0.0.2"
  },
  "dependencies": {},
  "readme": "#Transport\n\nA hub for centralizing all your request handlers within your application. Implements the disposable pattern.\n\n#Installation\n\n```bash\nnpm install transport\n```\n\n#How to use\n\nRequire and initialize transport:\n\n```js\nvar Transport = require(\"transport\"),\n  transport = new Transport();\n```\n\n## Requests\n\nDefine a `simpleHandler` to handle a request and send the result back:\n\n```js\n// Object with all the request handlers\nvar handlers = {\n    simpleHandler: function (payload, callback) {\n        // do something with the payload\n        var result = doSomethingWithPayload(payload);\n\n        // send the result back\n        callback(result);\n    }\n};\n```\n\nAdd the handler to `Transport`. The handlers have to be stored in an `observable-store`. This allows for sharing the same handlers between several implementations of `Transport` and react accordingly when handlers are added and removed.\n\n```js\nvar Store = require(\"observable-store\");\n\ntransport.setReqHandlers(new Store(handlers));\n```\n\nMake the request to `simpleHandler`:\n\n```js\ntransport.request(\"simpleHandler\", \"payload\", function callback(result) {\n    // do something with result\n});\n```\n\n## Open a channel\n\nLet's define a handler that will publish several updates.\n\n```js\nvar handlers = {\n    simpleChannel: function (payload, onEnd, onData) {\n        var stream = getStream(payload);\n\n        stream.on('data', onData);\n        stream.on('end', onEnd);\n    }\n};\n```\n\nNow we can open the channel and receive updates:\n\n```js\ntransport.listen(\"simpleChannel\", \"filename\", function onEnd(data) {\n    // Will be called when stream closes\n    console.log(\"END OF FILE\", data);\n}, function onData(data) {\n    // Will be called everytime some data is pushed\n    console.log(\"MORE DATA\", data);\n});\n```\n\n## Close/dispose an open channel\n\n`transport.listen` returns a function. When the `handler` also returns a function, it will be called by executing the one returned by `transport.listen`. It can be used to stop whatever the `handler` started and do some cleanup too.\n\n```js\nvar handlers = {\n    closableChannel: function (payload, onEnd, onData) {\n        var stream = getStream(payload);\n\n        stream.on(\"data\", onData);\n        stream.on(\"end\", onEnd);\n\n        return function stop() {\n            stream.removeListener(\"data\", onData);\n            stream.removeListener(\"end\", onEnd);\n        }\n    }\n};\n```\n\nNow, when calling `transport.listen`, we can call the `stop()` function returned by the `handler`.\n\n```js\nvar stop = transport.listen(\"closableChannel\", \"filename\", function onEnd() { ... }, function onData() { ... });\n\n// When calling stop, the stop() function returned by the handler will be executed.\nstop();\n```\n\n## Managing errors\n\nA convenient way to bubble up errors is to follow the error first convention:\n\n```js\nvar handlers = {\n    closableChannel: function (payload, onEnd, onData) {\n        var stream = getStream(payload);\n\n        stream.on(\"data\", onData);\n        stream.on(\"end\", function (data) {\n            onEnd(null, data);\n        });\n        stream.on(\"error\", function (error) {\n            onEnd(error);\n        });\n    }\n};\n````\n\nAnd now we can handle the errors in the onEnd callback.\n\n```js\ntransport.listen(\"closableChannel\", \"filename\", function onEnd(error, data) {\n    if (error) {\n        throw new Error(error);\n    }\n\n    // do something with data\n}, function onData() {\n        // ...\n});\n```\n\n\nLICENSE\n=======\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "transport@0.0.3",
  "dist": {
    "shasum": "9581790d012dfe6ce97a49346cb6425527ac89e0"
  },
  "_from": "transport@0.0.3",
  "_resolved": "https://registry.npmjs.org/transport/-/transport-0.0.3.tgz"
}
