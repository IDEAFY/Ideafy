{
  "name": "observable-store",
  "description": "An observable data store with dirty checking and computed properties",
  "version": "0.0.3",
  "homepage": "https://github.com/flams/observable-store",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/flams/observable-store/master/LICENSE"
    }
  ],
  "files": [
    "LICENSE",
    "index.js"
  ],
  "author": {
    "name": "Olivier Scherrer",
    "email": "pode.fr@gmail.com"
  },
  "keywords": [
    "data",
    "store",
    "datastore",
    "observable",
    "dirty",
    "checking",
    "computed"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:flams/observable-store.git"
  },
  "bugs": {
    "url": "https://github.com/flams/observable-store/issues"
  },
  "scripts": {
    "test": "jasmine-node test/"
  },
  "main": "index.js",
  "devDependencies": {
    "jasmine-node": "~1.14.3"
  },
  "dependencies": {
    "watch-notify": "0.0.2",
    "shallow-diff": "0.0.2",
    "shallow-copy": "0.0.1",
    "compare-numbers": "0.0.1",
    "object-count": "0.0.1",
    "nested-property": "0.0.1",
    "simple-loop": "0.0.2"
  },
  "readme": "<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](http://doctoc.herokuapp.com/)*\n\n- [Observable store](#observable-store)\n- [Installation](#installation)\n- [How to use](#how-to-use)\n\t- [Initialization](#initialization)\n\t- [Standard CRUD methods](#standard-crud-methods)\n\t- [Watch changes on specific property/item](#watch-changes-on-specific-propertyitem)\n\t- [Watch changes on generic events such as added/updated/deleted](#watch-changes-on-generic-events-such-as-addedupdateddeleted)\n\t- [Unwatch changes](#unwatch-changes)\n\t- [Using an array's native mutative methods](#using-an-arrays-native-mutative-methods)\n\t- [Using an array's accessor methods.](#using-an-arrays-accessor-methods)\n\t- [Computed properties](#computed-properties)\n\t- [Store reset](#store-reset)\n\t- [Store utilities](#store-utilities)\n- [LICENSE](#license)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\nObservable store\n=============\n\nAn observable data store with dirty checking and computed properties.\n\nInstallation\n============\n\n```bash\nnpm install observable-store\n```\n\nHow to use\n==========\n\nRequire observable-store:\n\n```js\nvar Store = require(\"observable-store\");\n```\n\n## Initialization\nIt can be initialized with or without data. When initialized with data, a shallow clone is done first.\n\n```js\n// Without data, an object based store:\nvar store = new Store({});\n\n// Without data, an array base store:\nvar store = new Store([]);\n\n// With an array\nvar store = new Store([\"array\", \"of\", \"items\"]);\n\n// With an object\nvar store = new Store({\n  property1: \"object\",\n  property2: \"with\",\n  property3: \"data\"\n});\n```\n## Standard CRUD methods\n\n```js\nstore.get(0); // \"array\";\nstore.get(\"property1\"); // \"object\"\n\nstore.set(0, \"new value\"); // set or update the value\nstore.set(\"property1\", \"new value\"); // set or update the value\n\nstore.del(0); // remove an item for the array\nstore.del(\"property1\"); // remove the property from the array\n\n// several items can be removed at once too\nstore.delAll([\"property1\", \"property2\"]);\n```\n\n## Watch changes on specific property/item\nThe point of proxying accessing objects/arrays is that it can trigger events on what's changing. Examples of watching changes on specific properties or items:\n\n```js\nvar handle = store.watchValue(\"property1\", function onPropertyUpdated(newValue, action, oldValue) {\n  // newValue == \"new value\";\n  // action == \"updated\"\n  // oldValue == \"object\"\n}, scope /* optional */);\n\nstore.set(\"property1\", \"new value\");\n```\n\n```js\nvar handle = store.watchValue(0, function onItemUpdated(newValue, action, oldValue) {\n    // newValue is undefined\n    // action == \"deleted\"\n    // oldValue == \"array\"\n}, scope /* optional */);\n\nstore.del(0);\n```\n\n```js\nvar handle = store.watchValue(3, function onItemUpdated(newValue, action, oldValue) {\n    // newValue == \"new value\"\n    // action == \"added\"\n    // oldValue is undefined\n}, scope /* optional */);\n\nstore.set(3, \"new value\");\n```\n\n## Watch changes on generic events such as added/updated/deleted\n\nYou can also watch generic events on the whole array/object to know when a new item or property is added, updated or deleted. The following examples are for an object-based store but work the same way with arrays.\n\n```js\nvar handle = store.watch(\"added\", function onPropertyAdded(propertyName, value) {\n    // propertyName == \"newProperty\"\n    // value == \"new value\"\n}, scope /* optional */);\n\nstore.set(\"newProperty\", \"new value\");\n```\n\n```js\nvar handle = store.watch(\"updated\", function onPropertyUpdated(propertyName, newValue, oldValue) {\n    // propertyName == \"newProperty\"\n    // newValue == \"updated value\"\n    // oldValue == \"new value\"\n}, scope /* optional */);\n\nstore.set(\"newProperty\", \"updated value\");\n```\n\n```js\nvar handle = store.watch(\"deleted\", function onPropertyDeleted(propertyName, newValue, oldValue) {\n    // propertyName == \"newProperty\"\n    // newValue is undefined\n    // oldValue == \"updated value\"\n});\n\nstore.del(\"newProperty\");\n```\n\n## Unwatch changes\n\nTo unwatch, pass the `handle` to `unwatch` or `unwatchValue`\n\n```js\nstore.unwatch(handle); // for handles created by watch\nstore.unwatchValue(handle); // for handles created by watchValue\n```\n\n## Using an array's native mutative methods\n\nThe data store has a method for accessing the array's native mutative methods to mutate the data store. When the changes have been made, the data store does a dirty check to figure out the changes and publish events accordingly. This example would also work with other methods than `splice` like `pop`, `push`, `shift`, `unshift`, `sort`, `reverse`.\n\n```js\n// Let's remove item 0 and 1 from this store\nvar store = new Store([0, 1, 2, 3]);\n\nstore.watch(\"updated\", function () {\n    // this will be triggered two times:\n    // The first item will be updated to 2\n    // The second item will be updated to 3\n});\n\nstore.watch(\"deleted\", function () {\n    // This will be triggered two times:\n    // The first 3rd item will be deleted\n    // The fourth item will be deleted\n});\n\n// For array-based stores\nstore.alter(\"splice\", 0, 1); // returns [0, 1];\n```\n\n## Using an array's accessor methods.\n\nWhile `alter` would work in these cases too, using `proxy` instead doesn't trigger the dirty checking, so `proxy` is as fast as the native method itself. Other accessor methods are: `concat`, `join`, `slice`, `toString`, `toLocalString`, `indexOf`, `lastIndexOf`.\n\n```js\nvar store = new Store([0, 1, 2, 3]);\n\nstore.proxy(\"join\", \"|\"); // returns \"0|1|2|3\";\n```\n\n## Computed properties\n\nThe data store can also create computed properties out of other properties:\n\n```js\nvar store = new Store({\n\t\"firstname\": \"John\",\n\t\"lastname\": \"Doe\"\n});\n\nstore.compute(\"name\", [\"firstname\", \"lastname\"], function (firstname, lastname) {\n\treturn this.get(firstname) + \" \" + this.get(lastname);\n}, store /* optional */);\n\nstore.get(\"name\"); // \"John Doe\"\n\nstore.isCompute(\"name\"); // true\n\nstore.removeComputed(\"name\");\n```\n\nA computed property can also be watched upon:\n\n```js\n// will be triggered if firstname or lastname changes\nstore.watchValue(\"name\", function () { ... });\n\nstore.set(\"firstname\", \"Jim\");\n```\n\n## Store reset\n\nThe store can be reused and its data reset. When calling reset, the store will do a diff with the previous data and publish the relevant events.\n\n```js\n// Will set the internal data and publish events for everything that has been changed/updated/added\nstore.reset({ ... });\n```\n\n## Store utilities\n\n```js\nstore.toJSON(); // will serialize the data\n\nstore.dump(); // will return the internal structure\n\nstore.loop(function (value, key, object) {\n\t// do something with each value/key\n\t// object === store.dump();\n}, scope /* optional */);\n```\n\n\nLICENSE\n=======\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "observable-store@0.0.3",
  "dist": {
    "shasum": "d8a37e3488c1312ad98dce6ad8a48497639cc746"
  },
  "_from": "observable-store@0.0.3",
  "_resolved": "https://registry.npmjs.org/observable-store/-/observable-store-0.0.3.tgz"
}
