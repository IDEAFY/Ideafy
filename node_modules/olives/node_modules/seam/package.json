{
  "name": "seam",
  "description": "Seam binds your JS logic to the DOM by adding configuration to the markup.",
  "version": "0.0.3",
  "homepage": "https://github.com/flams/seam",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/flams/seam/master/LICENSE"
    }
  ],
  "files": [
    "LICENSE",
    "index.js"
  ],
  "author": {
    "name": "Olivier Scherrer",
    "email": "pode.fr@gmail.com"
  },
  "keywords": [
    "html",
    "behavior",
    "plugin",
    "binding",
    "template",
    "declarative"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:flams/seam.git"
  },
  "bugs": {
    "url": "https://github.com/flams/seam/issues"
  },
  "scripts": {
    "test": "jasmine-node test/"
  },
  "main": "index.js",
  "devDependencies": {
    "jasmine-node": "~1.14.3",
    "quick-dom": "0.0.1"
  },
  "dependencies": {
    "to-array": "~0.1.4",
    "simple-loop": "0.0.2",
    "get-nodes": "0.0.1",
    "get-dataset": "0.0.1"
  },
  "readme": "Seam\n=============\n\nSeam binds your JS logic to the DOM by adding configuration to the markup.\n\nEver wanted to bind your JS logic to the DOM by doing something like this in your HTML?\n\n```html\n    <p data-bind=\"value: name\"></p>\n    <button data-listen=\"click: doSomething\"></button>\n```\n\nSeam allows you to do just that. It will create the link between your HTML and your JavaScript logic.\n\nInstallation\n============\n\n```bash\nnpm install seam\n```\n\nHow to use\n==========\n\nRequire seam:\n\n```js\nvar Seam = require(\"seam\");\n```\n\nLet's start with a simple example. We would like to set the value of \"name\" in the paragraph.\n\n### HTML\n\n```html\n\t<p data-bind=\"value: name\"></p>\n```\n\n### JavaScript\n\n```js\n\t// The object to display in the DOM\n\tvar someone = {\n\t\t// This is the value that we want to display in the paragraph\n\t\tname: \"John\",\n\t\ttype: \"Doe\"\n\t};\n\n\t// We start by initializing Seam\n\tvar seam = new Seam();\n\n\t// Then we add a seam plugin called 'bind'\n\tseam.add(\"bind\", {\n\n\t\t// Which has a method called value\n\t\tvalue: function (node, param) {\n\t\t\t// That will set the innerText of the dom to \"John\"\n\t\t\tnode.innerText = someone[param];\n\t\t}\n\t});\n\n\t// Then we tell it where to find the DOM elements to bind\n\tseam.apply(document.querySelector(\"p\"));\n```\n\nWhere data-bind is configured while adding the plugin to seam. We could have used any other allowed name, such as 'listen', 'style', 'css', 'text' or even 'another-plugin_for-seam'.\n\nSeam will then execute the method 'value' in the plugin 'bind', passing it two things:\n - {HTMLElement} the node to which the data-attribute is applied\n - {String} the parameters specified in the data-attribute, after the name of the method (name in our case)\n\nWe've just bound some JS logic to a dom element. This seems overkill for such simple task, but it'll make more sense when we'll add more plugins, and especially when they are plugins that we can just reuse.\n\n Let's add more plugins, one for setting data into the DOM, one for listening to DOM events.\n\n### HTML\n\n```html\n\t<section>\n\t\t<p data-bind=\"value: name\"></p>\n\t\t<button data-listen=\"click: doSomething\"></button>\n\t</section>\n```\n\nIn this case, we have two plugins, one called 'bind', and the other one called 'listen'. We can configure Seam to accept more than one plugin by calling the 'addAll' method instead of just 'add':\n\n```js\n\t// This is some UI with a doSomething method:\n\tvar ui = {\n\t\tdoSomething: function () {\n\t\t\t// do something\n\t\t}\n\t}\n\n\tseam.addAll({\n\t\t// This is the plugin that we have seen before\n\t\tbind: {\n\t\t\tvalue: function (node, param) {\n\t\t\t\tnode.innerText = someone[param];\n\t\t\t}\n\t\t},\n\n\t\t// This is the new plugin called listen\n\t\tlisten: {\n\t\t\tclick: function (node, method) {\n\t\t\t\tnode.addEventListener(\"click\", function (event) {\n\t\t\t\t\tui[method](event);\n\t\t\t\t}, true);\n\t\t\t}\n\t\t}\n\t});\n```\n\nWe still have the same plugin for adding data to the DOM. We also have added a new plugin called 'listen' that adds an eventListener to the targeted DOM. Whenever the user clicks on this DOM element, it will call the method 'doSomething' on UI.\n\nOf course, this example is very limited, as we can't bind a value from an object to something else than innerText, and we can't listen to another event than 'click' as long as we don't create new functions for handling them. Moreover, we can't change the object from which we get the value, nor can we change the object on which to call the method when a click occurs.\n\nSo let's create some reusable plugins. We pretend that the object that contains the data is a backbone.Model, which triggers events whenever something changes. We could also call a method on a backbone.View when a click occurs.\n\n### HTML\n\n```html\n\t<section>\n\t\t<p data-bind=\"change: name, innerText\"></p>\n\t\t<button data-event=\"listen: click, alert, name\"></p>\n\t</section>\n```\n\n### JavaScript\n\n```js\n\t// We have a backbone.Model\n\tmodel.set(\"name\", \"Seam\");\n\n\t// We have a backbone.View with an alert method. It alerts the value of \"name\"\n\tview.alert = function (event, param) {\n\t\talert(model.get(param);\n\t};\n\n\t/**\n\t * We create a constructor for a binding plugin\n\t * It takes a model as a parameter so it knows where to get the data\n\t */\n\tfunction Binding(model) {\n\n\t\t// This is the change method of our plugin\n\t\tthis.change = function (node, key, attribute) {\n\n\t\t\t// We need to set the innerText of the DOM to the current value\n\t\t\tnode[attribute] = model.get(key);\n\n\t\t\t// Whenever the value changes, we update the dom\n\t\t\tmodel.on(\"change:\" + key, function (newValue) {\n\t\t\t\tnode[attribute] = newValue;\n\t\t\t});\n\n\t\t};\n\t}\n\n\t/**\n\t * Then we create a constructor for an event plugin\n\t * It takes a view as parameter, so it knows where to call the method\n\t */\n\tfunction Event(view) {\n\n\t\tthis.event = function (node, eventName, methodName, param) {\n\t\t\tnode.addEventListener(eventName, function (event) {\n\t\t\t\tview[methodName](event, param);\n\t\t\t});\n\t\t};\n\n\t}\n\n\t// We create our Seam\n\tvar seam = new Seam();\n\n\t// Then we add our plugins\n\tseam.add({\n\n\t\t// We initialize a new binding plugin with the model we want to listen to\n\t\t\"bind\": new Binding(model),\n\n\t\t// We initialize a new event plugin with the view we want to call the methods on\n\t\t\"event\": new Event(view)\n\n\t});\n\n\t// And finally, we apply it to the parent element of the DOM that we want to bind to this logic\n\tseam.apply( document.querySelector(\"section\") );\n```\n\nIn this more complete example, we have a Binding plugin that will listen to changes on a backbone.Model to update the DOM. We have created a reusable data-binding plugin that can now be reused to bind as many backbone.Model as we want to our DOM. We have even specified which property of the DOM node we want to update. It could be the className, or even value for form elements!\n\nThen we have created an Event listener that will listen to 'click', or any other event we want to listen to, and forward the event to the method of the view that we have initialized the plugin with.\n\nWe can also call multiple methods on the same DOM element:\n\n```html\n\t<p data-plugin=\"method1: param1, param2, paramN; method2: param1, param2, paramN\"></p>\n```\n\nOr we can call multiple plugins on the same DOM element\n\n```html\n\t<p data-plugin1=\"method: param1, param2\" data-plugin2=\"method1: param1, param2; method2, param1, param2\"></p>\n```\n\nLICENSE\n=======\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "seam@0.0.3",
  "dist": {
    "shasum": "62b2a77c50f8fdc2e4d1791d93f7c036eecab1be"
  },
  "_from": "seam@0.0.3",
  "_resolved": "https://registry.npmjs.org/seam/-/seam-0.0.3.tgz"
}
